[["introduction.html", "Intro R 1 Introduction 1.1 R and RStudio 1.2 Installation 1.3 R syntax 1.4 Functions 1.5 Data types 1.6 Plotting 1.7 Sampling 1.8 Extras 1.9 Exercises", " Intro R Vittorio Zampinetti1 2022-09-25 1 Introduction 1.1 R and RStudio R: programming language, tailored for statisticians RStudio: development environment, software for editing and running R (and Python) applications ! It’s going to change name soon, see Posit 1.2 Installation First install R programming language (from here), then RStudio environment (from here). 1.3 R syntax Here a brief overview of the main components of the R language. Note: this is not a complete guide on the language nor on programming in general, but rather a quick-start introduction with the most used operations and structures, which assumes some very basic programming skills. For all the rest, Google is your friend (it really is). 1.3.1 Basic operations R can be used as a fully featured calculator, typically directly from the console (see bottom panel in RStudio). Some examples: 2 + 2 # calculator-style ## [1] 4 c(1, 2, 3) * 4 # vector operations ## [1] 4 8 12 t(matrix(c(c(1, 2, 3, 4)), nrow = 2, ncol = 2)) # matrix operations (transpose) ## [,1] [,2] ## [1,] 1 2 ## [2,] 3 4 As any other programming language, it allows for variables declaration. Variables hold a value which can be assigned, modified, and used for other computations. a &lt;- 2 # assign values to variables b = a + 2 # equal sign also valid, but... b ## [1] 4 The arrow sign &lt;- is the traditional sign for the assignment operation, but also = works. Check this examples to see why &lt;- is recommended. Conditional statements and loops have straightforward syntax (similar to C/C++ , but more compact). if (b == 4 &amp; a &gt; 0) { # if-else statement out &lt;- &quot;&quot; for (i in 1:b) { # for loop out &lt;- paste(out, class(b)) # concatenate two or more strings } print(out) # print string to output } else { stop(&quot;error&quot;) # stop program and exit } ## [1] &quot; numeric numeric numeric numeric&quot; 1.4 Functions Functions are called with the () operator and present named arguments. # get Normal samples with 0 (default) mean and 10 standard deviation array &lt;- rnorm(10, sd = 10) # sd is an argument, # the mean is left to the default 0 array ## [1] 2.023687 12.147226 -5.294969 9.196141 -6.256120 -8.185464 12.777032 -4.457083 15.605389 ## [10] -8.415337 You can explicitly call the arguments to which you want to pass the parameters (e.g. sd of the Gaussian). In this case it is necessary, because the second position argument is the mean, but we want it to be the default. 1.4.1 Definition To define a custom function # implements power operation #&#39; #&#39; @param x a real number #&#39; @param n a natural number, defaults to 2 #&#39; @return n-th power of x pow &lt;- function(x, n = 2) { ans &lt;- 1 if (n &gt; 0) { for (i in 1:n) { ans &lt;- ans * x } } else if (n == 0) { # do nothing, ans is already set to 1 } else { stop(&quot;error: n must be non-negative&quot;) } return(ans) } print(paste(&quot;3^5 = &quot;, pow(3, 5), &quot;, 4^2 = &quot;, pow(4), &quot;, 5^0 = &quot;, pow(5, 0))) ## [1] &quot;3^5 = 243 , 4^2 = 16 , 5^0 = 1&quot; The return() call can be omitted (but it’s better not to). pow &lt;- function(a, b) { ans &lt;- 1 # ... # last expression is returned ans # this is equivalent to write return(ans) } 1.5 Data types Every variable in R is an object, which holds a value (or collection of values) and some other attributes, properties or methods. 1.5.1 Base types There are 5 basic data types: - numeric (real numbers) - integer - logical (aka boolean) - character - complex (complex numbers) 1.5.1.1 Numeric When you write numbers in R, they are going to default to numeric type values a &lt;- 3.4 # decimal b &lt;- -.30 # signed decimal c &lt;- 42 # also without dot, it&#39;s numeric print(paste0(&quot;data types | a:&quot;, class(a), &quot;, b:&quot;, class(b), &quot;, c:&quot;, class(c))) ## [1] &quot;data types | a:numeric, b:numeric, c:numeric&quot; 1.5.1.2 Integer Integer numbers can be enforced typing an L next to the digits. Casting is implicit when the result of an operation involving integers is not an integer int_num &lt;- 50L # 50 stored as integer non_casted_num &lt;- int_num - 2L # result is exactly 48, still int casted_num &lt;- int_num / 7L # implicit cast to numeric type to store decimals print(paste(class(int_num), class(non_casted_num), class(casted_num), sep = &quot;, &quot;)) ## [1] &quot;integer, integer, numeric&quot; 1.5.1.3 Logical The logical type can only hold TRUE or FALSE (in capital letters) bool_a &lt;- FALSE bool_b &lt;- T # T and F are short for TRUE and FALSE bool_a == !bool_b # if &#39;A&#39; is not equal to &#39;not B&#39;, raise an error ## [1] TRUE You can test the value of a boolean also using 0,1 bool_a == 0 # if &#39;A&#39; is not equal to &#39;not B&#39;, raise an error ## [1] TRUE and a sum between logical values, treats FALSE = 0 and TRUE = 1, which is useful when counting true values in logical arrays bool_a + bool_b + bool_b # FALSE + TRUE + TRUE (it&#39;s not an OR operation) ## [1] 2 1.5.1.4 Character A character is any number of characters enclosed in quotes ' ' or double quotes \" \". char_a &lt;- &quot;,&quot; # single character char_b &lt;- &quot;bird&quot; # string char_c &lt;- &#39;word&#39; # single quotes full_char &lt;- paste(char_b, char_a, char_c) # concatenate chars class(full_char) # still a character ## [1] &quot;character&quot; 1.5.1.5 Complex complex_num &lt;- 5 + 4i Mod(complex_num) # try all complex operations, e.g. modulus ## [1] 6.403124 1.5.1.6 Special values NA: “not available”, missing value Inf: infinity NaN: “not-a-number”, undefined value missing_val &lt;- NA is.na(missing_val) # test if value is missing ## [1] TRUE Every operation involving missing values, will output NA missing_val == NA # cannot use == ## [1] NA print(paste( &quot;1/0 = &quot;, 1/0, &quot;, 0/0 = &quot;, 0/0 )) ## [1] &quot;1/0 = Inf , 0/0 = NaN&quot; These special values are not necessarily unwanted, but they require extra care. E.g. Inf can appear also in case of numerical overflow. exp(1000) ## [1] Inf 1.5.1.7 Conversion Variables types can be converted with as.&lt;typename&gt;()-like functions, as long as conversion makes sense. Some examples: v &lt;- T w &lt;- &quot;0&quot; x &lt;- 3.2 y &lt;- 2L z &lt;- &quot;F&quot; cat(paste( paste(x, as.integer(x), sep = &quot; =&gt; &quot;), # from numeric to integer paste(y, as.numeric(y), sep = &quot; =&gt; &quot;), # from integer to numeric paste(y, as.character(y), sep = &quot; =&gt; &quot;), # from integer to character paste(w, as.numeric(w), sep = &quot; =&gt; &quot;), # from number-char to numeric paste(v, as.numeric(v), sep = &quot; =&gt; &quot;), # from logical to numeric sep = &quot;\\n&quot; )) ## 3.2 =&gt; 3 ## 2 =&gt; 2 ## 2 =&gt; 2 ## 0 =&gt; 0 ## TRUE =&gt; 1 as.numeric(z) # from character to numeric (coercion warning - NA) ## Warning: NAs introduced by coercion ## [1] NA 1.5.2 Vectors and matrices 1.5.2.1 Vectors Vectors are build with the c() function. A vector holds values of the same type. vec1 &lt;- c(4, 3, 9, 5, 8) vec1 ## [1] 4 3 9 5 8 Vector operations and aggregation of values is as intuitive as it can be. vec2 &lt;- vec1 - 1 # subtract 1 to all values (broadcast) sum(vec1) # sum all values in vec1 ## [1] 29 mean(vec2) # compute the mean ## [1] 4.8 sort(vec1, decreasing = TRUE) # sort elements in decreasing order ## [1] 9 8 5 4 3 Conversion is still possible and it’s made element by element. char_vec &lt;- as.character(vec1) # convert every value in vec1 to char char_vec ## [1] &quot;4&quot; &quot;3&quot; &quot;9&quot; &quot;5&quot; &quot;8&quot; Range vectors (unit-stepped intervals) are built with start:end syntax. Note: the type of range vectors is integer, not numeric. x_range &lt;- 1:10 class(x_range) ## [1] &quot;integer&quot; They are particularly useful in loops statements: vec3 &lt;- c() # declare an empty vector # iterate all the indices along vec1 for (i in 1:length(vec1)) { vec3[i] &lt;- vec1[i] * i # access with [idx] } vec3 ## [1] 4 6 27 20 40 Vector elements are selected with square brackets []. Putting vectors inside brackets performs slicing vec1[1:3] # first 3 elements ## [1] 4 3 9 vec1[c(1,3)] # only first and third element ## [1] 4 9 vec1[c(-(1:3))] # all but elements 1 to 3 ## [1] 5 8 vec1[seq(1, length(vec1), 2)] # odd position elements ## [1] 4 9 8 To find an element in a vector and get its index/indices, the which() function can be used which(vec1 == 3) ## [1] 2 which(vec1 &lt; 5) ## [1] 1 2 And finally, to filter only values that satisfy a certain condition, we can combine which with splicing. vec1[which(vec1 &gt;= 5)] ## [1] 9 5 8 # or, equivalently, using logical masking vec1[vec1 &gt;= 5] ## [1] 9 5 8 1.5.2.2 Matrices Matrices are built with matrix() mat1 &lt;- matrix(1:24, nrow = 6, ncol = 4) mat1 # filled column-wise (default) ## [,1] [,2] [,3] [,4] ## [1,] 1 7 13 19 ## [2,] 2 8 14 20 ## [3,] 3 9 15 21 ## [4,] 4 10 16 22 ## [5,] 5 11 17 23 ## [6,] 6 12 18 24 mat2 &lt;- matrix(1:24, nrow = 6, ncol = 4, byrow = TRUE) mat2 # filled row-wise ## [,1] [,2] [,3] [,4] ## [1,] 1 2 3 4 ## [2,] 5 6 7 8 ## [3,] 9 10 11 12 ## [4,] 13 14 15 16 ## [5,] 17 18 19 20 ## [6,] 21 22 23 24 dim(mat2) # get dimensions ## [1] 6 4 c(nrow(mat2), ncol(mat2)) # get number of rows and cols separately ## [1] 6 4 # or, equivalently dim(mat2)[1] # nrow ## [1] 6 All indexing operations available on vectors, are also available on matrices mat2[1, 1] # element 1,1 ## [1] 1 mat2[3, ] # third row (empty space for all elements) ## [1] 9 10 11 12 mat2[1:2, 1:2] # upper left 2x2 sub-matrix ## [,1] [,2] ## [1,] 1 2 ## [2,] 5 6 t(mat2) # transposed matrix ## [,1] [,2] [,3] [,4] [,5] [,6] ## [1,] 1 5 9 13 17 21 ## [2,] 2 6 10 14 18 22 ## [3,] 3 7 11 15 19 23 ## [4,] 4 8 12 16 20 24 Operations with matrix and vectors can be both element-wise and matrix operations (e.g. scalar product). Note that a vector built with c() is a column vector by default. Some examples: diagonal_mat &lt;- diag(nrow = 4) # 4x4 identity matrix # element by element diagonal_mat * 1:2 # note: 1:2 is repeated to match the matrix dimensions ## [,1] [,2] [,3] [,4] ## [1,] 1 0 0 0 ## [2,] 0 2 0 0 ## [3,] 0 0 1 0 ## [4,] 0 0 0 2 diagonal_mat %*% seq(2, 8, 2) # matrix multiplication (4,4) x (4, 1) -&gt; (4, 1) ## [,1] ## [1,] 2 ## [2,] 4 ## [3,] 6 ## [4,] 8 v1 &lt;- 1:4 v2 &lt;- 4:1 v1 %*% v2 # here v1 is implicitly converted to row vector ## [,1] ## [1,] 20 1.5.2.3 Arrays Arrays are multi-dimensional vectors (generalization of a matrix with more than two dimensions). They work pretty much like matrices. arr1 &lt;- array(1:24, dim = c(2, 4, 3)) arr1 ## , , 1 ## ## [,1] [,2] [,3] [,4] ## [1,] 1 3 5 7 ## [2,] 2 4 6 8 ## ## , , 2 ## ## [,1] [,2] [,3] [,4] ## [1,] 9 11 13 15 ## [2,] 10 12 14 16 ## ## , , 3 ## ## [,1] [,2] [,3] [,4] ## [1,] 17 19 21 23 ## [2,] 18 20 22 24 arr1[2, 1, 3] # get one element ## [1] 18 sliced_arr &lt;- arr1[, 2, ] # slice at column 2 sliced_arr ## [,1] [,2] [,3] ## [1,] 3 11 19 ## [2,] 4 12 20 dim(sliced_arr) # reduces ndims by one (dimension selected is dropped) ## [1] 2 3 1.5.3 Lists and dataframes 1.6 Plotting 1.7 Sampling 1.8 Extras 1.8.1 File system and helper R language provides several tools for management of files and function help. # quali sono gli oggetti memorizzati nella console? ls() ## [1] &quot;a&quot; &quot;arr1&quot; &quot;array&quot; &quot;b&quot; &quot;bool_a&quot; ## [6] &quot;bool_b&quot; &quot;c&quot; &quot;casted_num&quot; &quot;char_a&quot; &quot;char_b&quot; ## [11] &quot;char_c&quot; &quot;char_vec&quot; &quot;complex_num&quot; &quot;diagonal_mat&quot; &quot;full_char&quot; ## [16] &quot;i&quot; &quot;int_num&quot; &quot;mat1&quot; &quot;mat2&quot; &quot;missing_val&quot; ## [21] &quot;non_casted_num&quot; &quot;out&quot; &quot;pow&quot; &quot;sliced_arr&quot; &quot;v&quot; ## [26] &quot;v1&quot; &quot;v2&quot; &quot;vec1&quot; &quot;vec2&quot; &quot;vec3&quot; ## [31] &quot;w&quot; &quot;x&quot; &quot;x_range&quot; &quot;y&quot; &quot;z&quot; # dove stiamo lavorando? Ossia in quale directory di lavoro (working directory) stiamo memorizzando i nostri dati? getwd() ## [1] &quot;/Users/zemp/phd/teach_ms/lessons&quot; # proviamo a cambiare la directory di lavoro # setwd(&quot;C:/Users/marti/OneDrive/Desktop/modelli_statistici/&quot;) getwd() ## [1] &quot;/Users/zemp/phd/teach_ms/lessons&quot; # tutto cio&#39; che salveremo da adesso in poi, verrà memorizzato in questa directory di lavoro. # salviamo l&#39;intero workspace dando un nome nostro file # save.image(&quot;Lez1.RData&quot;) # e vediamo che files sono stati salvati nella nostra directory di lavoro dir(all.files=TRUE) ## [1] &quot;_book&quot; &quot;_main.Rmd&quot; &quot;.&quot; &quot;..&quot; ## [5] &quot;.git&quot; &quot;.Rhistory&quot; &quot;01_intro_r_files&quot; &quot;01_intro_r.md&quot; ## [9] &quot;01_intro_r.pdf&quot; &quot;01_intro_r.Rmd&quot; &quot;404.html&quot; &quot;figure&quot; ## [13] &quot;introduction.html&quot; &quot;libs&quot; &quot;LICENSE&quot; #oppure list.files() ## [1] &quot;_book&quot; &quot;_main.Rmd&quot; &quot;01_intro_r_files&quot; &quot;01_intro_r.md&quot; ## [5] &quot;01_intro_r.pdf&quot; &quot;01_intro_r.Rmd&quot; &quot;404.html&quot; &quot;figure&quot; ## [9] &quot;introduction.html&quot; &quot;libs&quot; &quot;LICENSE&quot; ### Uscire: 2 diverse possibilità ### 1) chiudiamo dalla crocetta rossa: Salva area di lavoro? SI NO ### 2) digitiamo q() ### 1) e 2) salvano i seguenti oggetti: ###### File .RData : contiene il risultato di ciò che abbiamo eseguito ###### File .Rhistory: i comandi eseguiti (script) # Ripartiamo dalla sessione precedente andando a pescare # il file .RData dalla directory opportuna oppure # reimpartendo tutti i comandi precedenti memorizzati # nel file .Rhistory ####### ##### Come orientarsi e chiedere aiuto ad R? ####### help.start() # Browser #Per quanto riguarda la documentazione sulla sintassi di specifici comandi ed i #relativi argomenti opzionali sono utili i comandi in linea # help() # help.search() help(quit) #oppure ?quit # Quante altre operazioni numeriche e con quale sintassi? ?Arithmetic help(Arithmetic) help(Trig) help(Special) # Una volta ripresa la sessione in &quot;R console&quot; # vediamo cosa altro puo&#39; fare l&#39;ambiente R Most of these commands are also available throught RStudio graphical interface 1.8.2 Arrow sign The difference between &lt;- and = is not just programming style preference. Here an example where using = rather than &lt;- makes a difference: # gives error: argument &#39;b&#39; is not part of &#39;within&#39; within(data.frame(a= rnorm(2)), b = a^2) ## Error in eval(substitute(expr), e): argument is missing, with no default # &#39;b&lt;-a^2&#39; is the value passed to the expr argument of within() within(data.frame(a = rnorm(2)), b &lt;- a^2) ## a b ## 1 1.0139232 1.0280402 ## 2 -0.3713093 0.1378706 Although this event might never occur in one’s programming experience, it’s safer (and more elegant) to use &lt;- when assigning variable. Besides, -&gt; is also valid and it is used (more intuitive) when assigning pipes result to variables. library(dplyr) starwars %&gt;% dplyr::mutate(bmi = mass / ((height / 100) ^ 2)) %&gt;% dplyr::filter(!is.na(bmi)) %&gt;% dplyr::group_by(species) %&gt;% dplyr::summarise(bmi = mean(bmi)) %&gt;% dplyr::arrange(desc(bmi)) -&gt; x x ## # A tibble: 32 × 2 ## species bmi ## &lt;chr&gt; &lt;dbl&gt; ## 1 Hutt 443. ## 2 Vulptereen 50.9 ## 3 Yoda&#39;s species 39.0 ## 4 Kaleesh 34.1 ## 5 Droid 32.7 ## 6 Dug 31.9 ## 7 Trandoshan 31.3 ## 8 Sullustan 26.6 ## 9 Zabrak 26.1 ## 10 Besalisk 26.0 ## # … with 22 more rows 1.9 Exercises LogSumExp trick log_sum_exp2 &lt;- function(a, b) { max_el &lt;- max(a, b) sum_exp &lt;- sum(c(exp(a - max_el), exp(b - max_el))) return(log( sum_exp ) + max_el) } log_sum_exp2(a = -1000, b = -1001) ## [1] -999.6867 # see log-sum-exp trick: # https://en.wikipedia.org/wiki/LogSumExp#log-sum-exp_trick_for_log-domain_calculations While &lt;- is only used for variable assignment, i.e. filling up the variable allocated space with some value, the = is both used for assignment and function argument passing (as introduced in Functions). vittorio.zampinetti@polito.it↩︎ "]]
