stopifnot(all(dim(pois.mean) == c(B, C)))
# sample Y from poisson and return the dataset
for (c in 1:C) {
Y[,c] <- rpois(B, pois.mean[,c])
}
return(list(pi0 = pi0,
pi = pi,
s = s,
X = X,
mu = mu,
Y = Y))
}
gs_step <- function() {
return()
}
M <- 4
B <- 1000
C <- 30
dataset <- simulate_data(M, B, C)
n.test <- 10000 # simulations for test purposes
# TEST 1
# estimate s and fix all the rest
a0 <- .01
b0 <- 100
gamma.a <- a0 + apply(dataset$Y, MARGIN = 2, sum) # vector len C
gamma.b <- b0 / (1 + b0 * sum(dataset$mu * dataset$X)) # scalar
s.chain <- matrix(NA, nrow = n.test, ncol = C)
for (i in 1:n.test) {
s.new <- rgamma(C, gamma.a, scale = gamma.b)
s.chain[i,] <- s.new
}
# compare if the mean of the samples is close
# to the true values
# TODO: use confidence intervals to see how close
# the samples are to the true values
apply(s.chain, MARGIN = 2, mean)
dataset$s
# TEST 2
# estimate pi and fix all the rest
dir.alpha0 <- rep(.1, M)
cn.pair.counts <- matrix(0, nrow = M, ncol = M)
for (b in 2:B) {
i <- dataset$X[b-1] + 1
j <- dataset$X[b] + 1
# count the frequency of the edges/transitions
cn.pair.counts[i, j] = cn.pair.counts[i, j] + 1
}
dir.alpha.star <- dir.alpha0 + cn.pair.counts
# pi.chain: list of M matrices, each matrix is n.test x M
pi.chain <- lapply(1:M, function(i) {
pi.new <- rdirichlet(n.test, dir.alpha.star[i,])
return(pi.new)
})
# compare if the mean of the samples is close
# to the true values
do.call(rbind,
lapply(pi.chain, function(pi.mat) {
return(apply(pi.mat, MARGIN = 2, mean))
})
)
dataset$pi
# TEST 3
# estimate copy numbers and fix all the rest
# Note: here we sample all the sequence together
#   with forward-backward Gibbs sampling algorithm (FBG)
# compute the forward probabilities to the end recursively
# initialize the forward prob to 1/M * b(y1)
log.fwd <- -log(M) + sapply(0:(M-1), function (x) {
# compute the mean of the poisson for each copy number value
# given s (for each cell) and the fixed mu value
pois.mean.b <- dataset$s * x * dataset$mu[1]
log.emission <- sum(dpois(dataset$Y[1,], lambda = pois.mean.b, log = T))
return(log.emission)
})
# FIXME: fwd.filtered
fwd.filtered <- log.fwd - logSumExp(log.fwd)
fwd.filtered
x <- rnorm(1000)
quantile(x)
quantile(x, probs=c(0.025, 1-.025))
library(tidyverse)
library(gtools) # for dirichlet
library(matrixStats) # for logSumExp trick
library(gridExtra) # for multiple plots on pdf
# for reproducibility
set.seed(42)
load_data <- function(path) {
return()
}
rmc <- function(x0, length, pi0, pi) {
S <- 0:(nrow(pi)-1)
x0 <- sample(S, 1, prob = pi0)
X <- rep(0, length)
X[1] <- x0
for (t in 2:length) {
X[t] <- sample(S, 1, prob = pi[X[t-1] + 1,])
}
return(X)
}
simulate_data <- function(M, B, C) {
# disproportion parameter
dir.ralpha <- 10
# initial probability (uniform)
pi0 <- rep(1/M, M)
# transition probability (dirichlet)
pi <- matrix(nrow = M, ncol = M)
for (i in 1:M) {
dir.alpha.i <- rep(1, M)
dir.alpha.i[i] <- dir.ralpha
pi[i,] <- rdirichlet(1, dir.alpha.i)
}
# read depth (gamma)
gamma.a <- 10
gamma.b <- 1000
s <- rgamma(C, gamma.a, scale = gamma.b)
# copy numbers (markov chain)
X <- rmc(x0, B, pi0, pi)
# fix per-copy expression
mu <- rbeta(B, 1, 1000)
# simulate reads (poisson)
Y <- matrix(nrow = B, ncol = C)
pois.mean <- t(X * t(mu %*% t(s)))
stopifnot(all(dim(pois.mean) == c(B, C)))
# sample Y from poisson and return the dataset
for (c in 1:C) {
Y[,c] <- rpois(B, pois.mean[,c])
}
return(list(pi0 = pi0,
pi = pi,
s = s,
X = X,
mu = mu,
Y = Y))
}
gs_step <- function() {
return()
}
M <- 4
B <- 1000
C <- 30
dataset <- simulate_data(M, B, C)
n.test <- 10000 # simulations for test purposes
# TEST 1
# estimate s and fix all the rest
a0 <- .01
b0 <- 100
gamma.a <- a0 + apply(dataset$Y, MARGIN = 2, sum) # vector len C
gamma.b <- b0 / (1 + b0 * sum(dataset$mu * dataset$X)) # scalar
s.chain <- matrix(NA, nrow = n.test, ncol = C)
for (i in 1:n.test) {
s.new <- rgamma(C, gamma.a, scale = gamma.b)
s.chain[i,] <- s.new
}
# compare if the mean of the samples is close
# to the true values
# TODO: use confidence intervals to see how close
# quantile(samples, (.025, .975))
# TODO: print plots of the chain
# the samples are to the true values
dataset$s
apply(s.chain, MARGIN = 2, function (x) {
return(quantile(x, c(.025, .975)))
})
# TODO: finish this!
plts <- lapply(seq_len(C), FUN = function(i) {
sdf <- as.data.frame(cbind(idx = 1:n.test, val = s.chain[,i]))
ggplot(data = sdf) +
geom_line(mapping = aes(x = idx, y = val)) +
geom_hline(mapping = aes(yintercept = dataset$s[i], color = "red")) +
ggtitle(cat("Cell ", i, " samples")) +
xlab("samples") + ylab("val")
})
ggsave("s_plots.pdf", marrangeGrob(grobs = plts, nrow = 4, ncol = 2))
system("type R")
library(tidyverse)
library(gtools) # for dirichlet
library(matrixStats) # for logSumExp trick
library(gridExtra) # for multiple plots on pdf
system("type R")
install.packages(c("cluster", "glmnet", "haven", "later", "Matrix", "openssl", "sass"))
library(gridExtra)
knitr::opts_chunk$set(echo = TRUE)
ls()
getwd()
# implements power operation
#'
#' @param x a real number
#' @param n a natural number, defaults to 2
#' @return n-th power of x
pow <- function(x, n = 2) {
ans <- 1
if (n >= 0) {
for (i in 1:n) {
ans <- ans * x
}
} else {
stop("error: n must be non-negative")
}
return(ans)
}
print(paste("3^5 = ", pow(3, 5),
", 4^2 = ", pow(4)))
pow(2,0)
for (i in 1:n) {}
for (i in 1:0) {
print(i)
}
for (i in 0:0) {
print(i)
}
# implements power operation
#'
#' @param x a real number
#' @param n a natural number, defaults to 2
#' @return n-th power of x
pow <- function(x, n = 2) {
ans <- 1
if (n > 0) {
for (i in 1:n) {
ans <- ans * x
}
} else if (n == 0) {
break
} else {
stop("error: n must be non-negative")
}
return(ans)
}
print(paste("3^5 = ", pow(3, 5),
", 4^2 = ", pow(4)))
pow(2,0)
# implements power operation
#'
#' @param x a real number
#' @param n a natural number, defaults to 2
#' @return n-th power of x
pow <- function(x, n = 2) {
ans <- 1
if (n > 0) {
for (i in 1:n) {
ans <- ans * x
}
} else if (n == 0) {
# do nothing, ans is already set to 1
} else {
stop("error: n must be non-negative")
}
return(ans)
}
print(paste("3^5 = ", pow(3, 5),
", 4^2 = ", pow(4)))
print(paste("3^5 = ", pow(3, 5),
", 4^2 = ", pow(4),
", 5^0 = ", pow(5, 0)))
a <- 3.4 # decimal
b <- -.30 # signed decimal
c <- 42 # also without dot, it's numeric
print(paste("data types: a(", class(a),
"), b(", class(b),
"), c(", class(c), ")"))
a <- 3.4 # decimal
b <- -.30 # signed decimal
c <- 42 # also without dot, it's numeric
print(paste0("data types: a(", class(a),
"), b(", class(b),
"), c(", class(c), ")"))
a <- 3.4 # decimal
b <- -.30 # signed decimal
c <- 42 # also without dot, it's numeric
print(paste0("data types | a:", class(a),
", b:", class(b),
", c:", class(c)))
int_num <- 50L
casted_num <- int_num / 3L
print(paste(class(int_num), class(casted_num)))
int_num <- 50L
casted_num <- int_num / 3L
print(paste(class(int_num), class(casted_num), sep = ", "))
int_num <- 50L #
casted_num <- int_num / 3L
print(paste(typeof(int_num), class(casted_num), sep = ", "))
int_num <- 50L #
casted_num <- int_num / 3L
print(paste(typeof(int_num), typeof(casted_num), sep = ", "))
int_num <- 50L #
casted_num <- int_num / 3L
print(paste(class(int_num), class(casted_num), sep = ", "))
y <- 1:10
class(y)
typeof(y)
object.size(int_num)
int_num <- 50L # 50 stored as integer
casted_num <- int_num // 3L
non_casted_num
non_casted_num <- int_num - 2L
non_casted_num
class(non_casted_num)
casted_num
casted_num <- int_num / 7L #
casted_num
str(a)
string(a)
as.character(a)
mode(a)
complex_num <- 5 + 4i
Mod(complex_num) # try all complex operations, e.g. modulus
bool_a <- FALSE
bool_b <- T # T and F are short for TRUE and FALSE
assert(bool_a == !bool_b) # if 'A' is not equal to 'not B', raise an error
stopifnot(bool_a == !bool_b) # if 'A' is not equal to 'not B', raise an error
bool_a == 0 # if 'A' is not equal to 'not B', raise an error
bool_a + bool_a + bool_b
sum(c(bool_a, bool_a, bool_b))
bool_a + bool_b + bool_b
char_a <- "," # single character
char_b <- "bird" # string
char_c <- 'word' # single quotes
char_a + char_b + char_c
paste(char_b, char_a, char_c)
cat(char_b, int_num)
class(cat(char_b, int_num))
class(paste(char_b, int_num))
full_char <- paste(char_b, char_a, char_c) # concatenate chars
print(full_char)
class(full_char)
char_a <- "," # single character
char_b <- "bird" # string
char_c <- 'word' # single quotes
full_char <- paste(char_b, char_a, char_c) # concatenate chars
print(full_char)
class(full_char)
paste(c("a", "b"))
paste(c("a", "b"), collapse = '')
v <- T
w <- "0"
x <- 3.2
y <- 2L
z <- "F"
as.integer(x) # from numeric to integer
as.numeric(y) # from integer to numeric
as.character(y) # from integer to character
as.numeric(w) # from number-char to numeric
as.numeric(T) # from logical to numeric
as.numeric(z) # from character to numeric (error)
paste(x, as.integer(x), sep = " => ") # from numeric to integer
paste(y, as.numeric(y), sep = " => ") # from integer to numeric
paste(y, as.character(y), sep = " => ")  # from integer to character
paste(w, as.numeric(w), sep = " => ")  # from number-char to numeric
paste(v, as.numeric(v), sep = " => ")  # from logical to numeric
paste(z, as.numeric(z), sep = " => ")  # from character to numeric (coercion warning - NA)
paste(
paste(x, as.integer(x), sep = " => "), # from numeric to integer
paste(y, as.numeric(y), sep = " => "), # from integer to numeric
paste(y, as.character(y), sep = " => "),  # from integer to character
paste(w, as.numeric(w), sep = " => "),  # from number-char to numeric
paste(v, as.numeric(v), sep = " => "), # from logical to numeric
sep = "\n"
)
paste(
paste(x, as.integer(x), sep = " => "), # from numeric to integer
paste(y, as.numeric(y), sep = " => "), # from integer to numeric
paste(y, as.character(y), sep = " => "),  # from integer to character
paste(w, as.numeric(w), sep = " => "),  # from number-char to numeric
paste(v, as.numeric(v), sep = " => "), # from logical to numeric
sep = "\\n"
)
print(paste(
paste(x, as.integer(x), sep = " => "), # from numeric to integer
paste(y, as.numeric(y), sep = " => "), # from integer to numeric
paste(y, as.character(y), sep = " => "),  # from integer to character
paste(w, as.numeric(w), sep = " => "),  # from number-char to numeric
paste(v, as.numeric(v), sep = " => "), # from logical to numeric
sep = "\n"
))
print(paste(
paste(x, as.integer(x), sep = " => "), # from numeric to integer
paste(y, as.numeric(y), sep = " => "), # from integer to numeric
paste(y, as.character(y), sep = " => "),  # from integer to character
paste(w, as.numeric(w), sep = " => "),  # from number-char to numeric
paste(v, as.numeric(v), sep = " => "), # from logical to numeric
sep = '\n'
))
cat(paste(
paste(x, as.integer(x), sep = " => "), # from numeric to integer
paste(y, as.numeric(y), sep = " => "), # from integer to numeric
paste(y, as.character(y), sep = " => "),  # from integer to character
paste(w, as.numeric(w), sep = " => "),  # from number-char to numeric
paste(v, as.numeric(v), sep = " => "), # from logical to numeric
sep = '\n'
))
missing_val <- NA
print(paste(is.na(missing_val),
missing_val == NA)
) # test if a value is missing (cannot use ==)
missing_val <- NA
print(paste(is.na(missing_val),
missing_val == NA), sep = ", ")
# test if a value is missing (cannot use ==)
missing_val <- NA
print(paste(is.na(missing_val),
missing_val == NA, sep = ", "))
# test if a value is missing (cannot use ==)
print(paste(
"1/0 = ", 1/0,
"0/0 = ", 0/0, sep = ","
))
print(paste(
"1/0 = ", 1/0,
", 0/0 = ", 0/0
))
install.packages("bookdown")
unlink("phd/teach_ms/lessons/01_intro_r_cache", recursive = TRUE)
bookdown::gitbook("~/phd/teach_ms/lessons/01_intro_r.Rmd", "bookdown::gitbook")
bookdown::render_book("~/phd/teach_ms/lessons/01_intro_r.Rmd", "bookdown::gitbook")
setwd("phd/teach_ms/lessons")
bookdown::render_book("01_intro_r.Rmd", "bookdown::gitbook")
knitr::opts_chunk$set(echo = TRUE)
data_frame(x = 1:15, y = 1:3, z = x / y)
data_frame(x = 1:15, y = 1, z = x / y)
data_frame(x = 1:8, y = 1, z = x / y,
char = letters[1:8])
df1 # notice that x has one value which gets repeated ('recycle')
df1 <- data.frame(x = 1, y = 1:10,
char = sample(c("a", "b"), 10, replace = TRUE))
df1 # notice that x has one value which gets repeated ('recycle')
df1[[2]] # access through column index
df1$x # access through column name
df1[, 3] # access with matrix-style index
df1[2:4, ] # can also select subset of rows
# generate synthetic data
n_points <- 30
x = 1:n_points
y = 3 * x + rnorm(n_points)
plot(x, y)
abline(coef = 3)
# generate synthetic data
n_points <- 30
x = 1:n_points
y = 3 * x + 2 * rnorm(n_points)
plot(x, y)
abline(coef = 3)
abline(b = 3, col = 'red')
# generate synthetic data
n_points <- 30
x = 1:n_points
y = 3 * x + 2 * rnorm(n_points)
plot(x, y)
abline(b = 3, col = 'red')
# generate synthetic data
n_points <- 30
x = 1:n_points
y = 3 * x + 2 * rnorm(n_points)
plot(x, y)
abline(b = 3, col = 'red')
abline(a = 0, b = 3, col = 'red')
# generate synthetic data
n_points <- 30
x = 1:n_points
y = 3 * x + 2 * rnorm(n_points)
plot(x, y)
abline(a = 0, b = 3, col = 'red')
vignette(ggplot2\)
vignette(ggplot2)
vignette("ggplot2")
library(ggplot2)
library(ggplot2)
gg_df <- data_frame(x = x, y = y)
ggplot(gg_df) +
geom_point(mapping = aes(x, y)) +
geom_abline(mapping = aes(intercep = 0, slope = 3, fill = "red"))
ggplot(gg_df) +
geom_point(mapping = aes(x, y)) +
geom_abline(mapping = aes(intercept = 0, slope = 3, fill = "red"))
ggplot(gg_df) +
geom_point(mapping = aes(x, y)) +
geom_abline(mapping = aes(intercept = 0, slope = 3, color = "red"))
ggplot(gg_df) +
geom_point(mapping = aes(x, y)) +
geom_abline(mapping = aes(intercept = 0, slope = 3) color = "red")
ggplot(gg_df) +
geom_point(mapping = aes(x, y)) +
geom_abline(mapping = aes(intercept = 0, slope = 3) color = "red")
ggplot(gg_df) +
geom_point(mapping = aes(x, y)) +
geom_abline(mapping = aes(intercept = 0, slope = 3), color = "red")
mtcars
mtcars %>%
dplyr::filter(hp > 100) %>%
dplyr::select(rownames(mtcars))
mtcars %>%
dplyr::filter(hp > 100) %>%
dplyr::select(name)
library("tibble")
data_frame(x = 1:15, y = 1:3, z = x / y) # tibble dataframe (with _ and not .)
data_frame(x = 1:15, y = 1, z = x / y) # tibble dataframe (with _ and not .)
mtcars
as_data_frame(mtcars)
mtcars$modelname <- rownames(mtcars)
mtcars
mtcars
mtcars %>%
dplyr::filter(hp > 100) %>%
dplyr::select(modelname)
mtcars <- as_data_frame(mtcars)
mtcars %>%
dplyr::filter(hp > 100) %>%
dplyr::select(modelname)
mtcars
mtcars %>%
dplyr::filter(hp > 100) %>%
dplyr::select(modelname) %>%
dplyr::arrange(modelname)
